/**
 * Video-to-Document Knowledge Connections System
 * 
 * Connects video wisdom extracts to relevant knowledge documents,
 * business cases, tools, and other content across the site
 */

import { getVideoDatabase } from './database/video-database';

export interface KnowledgeConnection {
  id: string;
  episodeId: string;
  episodeTitle: string;
  wisdomExtractId?: string;
  wisdomContent?: string;
  
  // Connection target
  documentId: string;
  documentTitle: string;
  documentType: 'knowledge-doc' | 'business-case' | 'tool' | 'newsletter' | 'video';
  documentUrl: string;
  
  // Connection metadata
  relationshipType: 'references' | 'expands-on' | 'example-of' | 'contradicts' | 'builds-upon';
  relevanceScore: number; // 0-1
  connectionDescription: string;
  
  // Context
  episodeTimestamp?: number;
  documentSection?: string;
  themes: string[];
  
  // Verification
  autoGenerated: boolean;
  manuallyVerified: boolean;
  confidence: number;
  
  createdAt: string;
}

export interface DocumentReference {
  id: string;
  title: string;
  type: string;
  url: string;
  description?: string;
  themes?: string[];
  section?: string;
}

// Knowledge base mapping - connects AIME concepts to content URLs
const KNOWLEDGE_BASE_MAPPING = {
  // Core concepts
  'hoodie-economics': {
    id: 'hoodie-economics',
    title: 'Hoodie Economics',
    type: 'knowledge-doc',
    url: '/knowledge-synthesis#hoodie-economics',
    description: 'Relational economics framework that prioritizes relationships and community wealth',
    themes: ['economics', 'relationships', 'community-wealth', 'alternative-economics'],
    keywords: ['hoodie economics', 'relational economics', 'community wealth', 'relationship first']
  },
  
  'seven-generation-thinking': {
    id: 'seven-generation-thinking',
    title: 'Seven Generation Thinking',
    type: 'knowledge-doc', 
    url: '/knowledge-synthesis#seven-generation-thinking',
    description: 'Indigenous principle of considering impacts seven generations into the future',
    themes: ['indigenous-wisdom', 'long-term-thinking', 'sustainability', 'decision-making'],
    keywords: ['seven generation', 'long term thinking', 'indigenous wisdom', 'future impact']
  },
  
  'systems-thinking': {
    id: 'systems-thinking',
    title: 'Systems Thinking',
    type: 'knowledge-doc',
    url: '/knowledge-synthesis#systems-thinking',
    description: 'Understanding interconnections and relationships within complex systems',
    themes: ['systems-thinking', 'complexity', 'relationships', 'holistic-thinking'],
    keywords: ['systems thinking', 'complexity', 'interconnection', 'holistic']
  },
  
  'mentoring-methodology': {
    id: 'mentoring-methodology',
    title: 'AIME Mentoring Methodology',
    type: 'knowledge-doc',
    url: '/knowledge-synthesis#mentoring',
    description: 'Relationship-first mentoring approach that unlocks potential',
    themes: ['mentoring', 'relationships', 'potential', 'youth-development'],
    keywords: ['mentoring', 'relationship first', 'potential', 'youth development']
  },
  
  'imagination-based-learning': {
    id: 'imagination-based-learning',
    title: 'Imagination-Based Learning',
    type: 'knowledge-doc',
    url: '/knowledge-synthesis#imagination',
    description: 'Educational approach that centers imagination and creativity',
    themes: ['imagination', 'education', 'creativity', 'learning-design'],
    keywords: ['imagination', 'creative learning', 'education transformation']
  }
};

// Business case mapping
const BUSINESS_CASE_MAPPING = {
  'imagi-labs': {
    id: 'imagi-labs',
    title: 'IMAGI-Labs Program',
    type: 'business-case',
    url: '/business-cases#imagi-labs',
    description: 'Innovation labs that bridge Indigenous knowledge with modern challenges',
    themes: ['innovation', 'indigenous-knowledge', 'labs', 'education'],
    keywords: ['imagi labs', 'innovation labs', 'indigenous knowledge', 'practical innovation']
  },
  
  'mentoring': {
    id: 'mentoring',
    title: 'Mentoring Program Framework',
    type: 'business-case',
    url: '/business-cases#mentoring',
    description: 'Comprehensive mentoring program design and implementation',
    themes: ['mentoring', 'program-design', 'youth-development', 'relationships'],
    keywords: ['mentoring program', 'youth development', 'relationship building']
  },
  
  'systems-residency': {
    id: 'systems-residency',
    title: 'Systems Residency',
    type: 'business-case',
    url: '/business-cases#systems-residency',
    description: 'Immersive learning experience in systems thinking and change',
    themes: ['systems-thinking', 'residency', 'immersive-learning', 'change-making'],
    keywords: ['systems residency', 'immersive learning', 'change making']
  }
};

export class KnowledgeConnectionManager {
  private db: any;
  
  constructor() {
    this.initializeDatabase();
  }
  
  private async initializeDatabase() {
    this.db = await getVideoDatabase();
  }
  
  /**
   * Generate connections between video wisdom extracts and knowledge documents
   */
  async generateConnectionsForEpisode(episodeId: string): Promise<KnowledgeConnection[]> {
    await this.initializeDatabase();
    
    const episode = await this.db.getEpisode(episodeId);
    if (!episode) {
      throw new Error(`Episode ${episodeId} not found`);
    }
    
    const wisdomExtracts = await this.db.getEpisodeWisdom(episodeId, true); // Only approved
    const connections: KnowledgeConnection[] = [];
    
    for (const extract of wisdomExtracts) {
      const extractConnections = await this.findConnectionsForWisdom(episode, extract);
      connections.push(...extractConnections);
    }
    
    // Also check episode-level themes and content
    const episodeConnections = await this.findConnectionsForEpisode(episode);
    connections.push(...episodeConnections);
    
    // Store connections in database
    for (const connection of connections) {
      await this.storeConnection(connection);
    }
    
    return connections;
  }
  
  /**
   * Find knowledge connections for a specific wisdom extract
   */
  private async findConnectionsForWisdom(episode: any, extract: any): Promise<KnowledgeConnection[]> {
    const connections: KnowledgeConnection[] = [];
    const extractText = extract.content.toLowerCase();
    const themes = extract.themes || [];
    
    // Check knowledge base connections
    for (const [key, doc] of Object.entries(KNOWLEDGE_BASE_MAPPING)) {
      const relevanceScore = this.calculateRelevance(extractText, themes, doc);
      
      if (relevanceScore > 0.3) { // Threshold for relevance
        connections.push({
          id: `${extract.id}-${doc.id}`,
          episodeId: episode.id,
          episodeTitle: episode.title,
          wisdomExtractId: extract.id,
          wisdomContent: extract.content,
          
          documentId: doc.id,
          documentTitle: doc.title,
          documentType: doc.type as any,
          documentUrl: doc.url,
          
          relationshipType: this.determineRelationshipType(extractText, doc),
          relevanceScore,
          connectionDescription: this.generateConnectionDescription(extract, doc, relevanceScore),
          
          episodeTimestamp: extract.timestamp_start,
          themes: [...new Set([...themes, ...doc.themes])],
          
          autoGenerated: true,
          manuallyVerified: false,
          confidence: relevanceScore,
          
          createdAt: new Date().toISOString()
        });
      }
    }
    
    // Check business case connections
    for (const [key, businessCase] of Object.entries(BUSINESS_CASE_MAPPING)) {
      const relevanceScore = this.calculateRelevance(extractText, themes, businessCase);
      
      if (relevanceScore > 0.3) {
        connections.push({
          id: `${extract.id}-${businessCase.id}`,
          episodeId: episode.id,
          episodeTitle: episode.title,
          wisdomExtractId: extract.id,
          wisdomContent: extract.content,
          
          documentId: businessCase.id,
          documentTitle: businessCase.title,
          documentType: businessCase.type as any,
          documentUrl: businessCase.url,
          
          relationshipType: 'example-of',
          relevanceScore,
          connectionDescription: this.generateConnectionDescription(extract, businessCase, relevanceScore),
          
          episodeTimestamp: extract.timestamp_start,
          themes: [...new Set([...themes, ...businessCase.themes])],
          
          autoGenerated: true,
          manuallyVerified: false,
          confidence: relevanceScore,
          
          createdAt: new Date().toISOString()
        });
      }
    }
    
    return connections;
  }
  
  /**
   * Find connections at the episode level (themes, learning objectives)
   */
  private async findConnectionsForEpisode(episode: any): Promise<KnowledgeConnection[]> {
    const connections: KnowledgeConnection[] = [];
    const episodeThemes = episode.themes || [];
    const learningObjectives = episode.learning_objectives || [];
    const description = episode.description.toLowerCase();
    
    // Combine all episode content for analysis
    const episodeContent = [
      episode.title,
      episode.description,
      ...learningObjectives
    ].join(' ').toLowerCase();
    
    // Check for high-level knowledge connections
    for (const [key, doc] of Object.entries(KNOWLEDGE_BASE_MAPPING)) {
      const relevanceScore = this.calculateRelevance(episodeContent, episodeThemes, doc);
      
      if (relevanceScore > 0.4) { // Higher threshold for episode-level connections
        connections.push({
          id: `${episode.id}-episode-${doc.id}`,
          episodeId: episode.id,
          episodeTitle: episode.title,
          
          documentId: doc.id,
          documentTitle: doc.title,
          documentType: doc.type as any,
          documentUrl: doc.url,
          
          relationshipType: 'expands-on',
          relevanceScore,
          connectionDescription: `Episode "${episode.title}" explores concepts related to ${doc.title}`,
          
          themes: [...new Set([...episodeThemes, ...doc.themes])],
          
          autoGenerated: true,
          manuallyVerified: false,
          confidence: relevanceScore,
          
          createdAt: new Date().toISOString()
        });
      }
    }
    
    return connections;
  }
  
  /**
   * Calculate relevance score between content and document
   */
  private calculateRelevance(content: string, themes: string[], doc: any): number {
    let score = 0;
    
    // Keyword matching
    const keywords = doc.keywords || [];
    for (const keyword of keywords) {
      if (content.includes(keyword.toLowerCase())) {
        score += 0.3;
      }
    }
    
    // Theme overlap
    const docThemes = doc.themes || [];
    const themeOverlap = themes.filter(theme => 
      docThemes.some(docTheme => 
        theme.includes(docTheme) || docTheme.includes(theme)
      )
    ).length;
    
    score += (themeOverlap / Math.max(themes.length, docThemes.length)) * 0.5;
    
    // Title/concept matching
    if (content.includes(doc.title.toLowerCase())) {
      score += 0.4;
    }
    
    // Specific concept matching
    const conceptMatches = [
      { pattern: /seven generation/i, concepts: ['seven-generation-thinking'] },
      { pattern: /hoodie economic/i, concepts: ['hoodie-economics'] },
      { pattern: /systems thinking/i, concepts: ['systems-thinking'] },
      { pattern: /mentor/i, concepts: ['mentoring-methodology'] },
      { pattern: /imagination/i, concepts: ['imagination-based-learning'] }
    ];
    
    for (const match of conceptMatches) {
      if (match.pattern.test(content) && match.concepts.includes(doc.id)) {
        score += 0.6;
      }
    }
    
    return Math.min(score, 1.0); // Cap at 1.0
  }
  
  /**
   * Determine the type of relationship between content and document
   */
  private determineRelationshipType(content: string, doc: any): 'references' | 'expands-on' | 'example-of' | 'contradicts' | 'builds-upon' {
    // Simple heuristics for relationship types
    if (content.includes('example') || content.includes('case study')) {
      return 'example-of';
    }
    
    if (content.includes('builds on') || content.includes('foundation')) {
      return 'builds-upon';
    }
    
    if (content.includes('refers to') || content.includes('mentioned')) {
      return 'references';
    }
    
    // Default to expands-on for most knowledge connections
    return 'expands-on';
  }
  
  /**
   * Generate human-readable connection description
   */
  private generateConnectionDescription(extract: any, doc: any, relevanceScore: number): string {
    const confidence = relevanceScore > 0.7 ? 'strongly' : relevanceScore > 0.5 ? 'moderately' : 'potentially';
    
    const templates = [
      `This wisdom extract ${confidence} relates to the concept of ${doc.title}`,
      `The insights shared here connect to ${doc.title} from the knowledge base`,
      `This teaching ${confidence} expands upon ideas in ${doc.title}`,
      `The principles discussed align with ${doc.title}`
    ];
    
    return templates[Math.floor(Math.random() * templates.length)];
  }
  
  /**
   * Store connection in database
   */
  private async storeConnection(connection: KnowledgeConnection): Promise<void> {
    try {
      await this.db.createKnowledgeConnection({
        id: connection.id,
        episode_id: connection.episodeId,
        document_id: connection.documentId,
        document_title: connection.documentTitle,
        document_type: connection.documentType,
        relationship_type: connection.relationshipType,
        relevance_score: connection.relevanceScore,
        episode_timestamp: connection.episodeTimestamp,
        document_section: connection.documentSection,
        connection_description: connection.connectionDescription,
        auto_generated: connection.autoGenerated,
        manually_verified: connection.manuallyVerified
      });
    } catch (error) {
      console.warn(`Failed to store connection ${connection.id}:`, error);
    }
  }
  
  /**
   * Get connections for a specific episode
   */
  async getEpisodeConnections(episodeId: string): Promise<KnowledgeConnection[]> {
    await this.initializeDatabase();
    
    try {
      const connections = await this.db.getEpisodeKnowledgeConnections(episodeId);
      return connections.map(this.formatConnection);
    } catch (error) {
      console.warn(`Failed to get connections for episode ${episodeId}:`, error);
      return [];
    }
  }
  
  /**
   * Get connections for a specific document
   */
  async getDocumentConnections(documentId: string): Promise<KnowledgeConnection[]> {
    await this.initializeDatabase();
    
    try {
      const connections = await this.db.getDocumentKnowledgeConnections(documentId);
      return connections.map(this.formatConnection);
    } catch (error) {
      console.warn(`Failed to get connections for document ${documentId}:`, error);
      return [];
    }
  }
  
  /**
   * Format database connection to interface
   */
  private formatConnection(dbConnection: any): KnowledgeConnection {
    return {
      id: dbConnection.id,
      episodeId: dbConnection.episode_id,
      episodeTitle: dbConnection.episode_title || '',
      documentId: dbConnection.document_id,
      documentTitle: dbConnection.document_title,
      documentType: dbConnection.document_type,
      documentUrl: this.generateDocumentUrl(dbConnection.document_id, dbConnection.document_type),
      relationshipType: dbConnection.relationship_type,
      relevanceScore: dbConnection.relevance_score,
      connectionDescription: dbConnection.connection_description,
      episodeTimestamp: dbConnection.episode_timestamp,
      documentSection: dbConnection.document_section,
      themes: [], // Would need to be populated from related data
      autoGenerated: dbConnection.auto_generated,
      manuallyVerified: dbConnection.manually_verified,
      confidence: dbConnection.relevance_score,
      createdAt: dbConnection.created_at
    };
  }
  
  /**
   * Generate URL for document based on ID and type
   */
  private generateDocumentUrl(documentId: string, documentType: string): string {
    switch (documentType) {
      case 'knowledge-doc':
        return `/knowledge-synthesis#${documentId}`;
      case 'business-case':
        return `/business-cases#${documentId}`;
      case 'tool':
        return `/tools#${documentId}`;
      case 'newsletter':
        return `/newsletters#${documentId}`;
      default:
        return `/discover?q=${encodeURIComponent(documentId)}`;
    }
  }
  
  /**
   * Generate all connections for all episodes
   */
  async generateAllConnections(): Promise<number> {
    await this.initializeDatabase();
    
    const { episodes } = await this.db.getEpisodes({ status: 'published', limit: 1000 });
    let totalConnections = 0;
    
    for (const episode of episodes) {
      try {
        const connections = await this.generateConnectionsForEpisode(episode.id);
        totalConnections += connections.length;
        console.log(`Generated ${connections.length} connections for episode: ${episode.title}`);
      } catch (error) {
        console.error(`Failed to generate connections for episode ${episode.id}:`, error);
      }
    }
    
    return totalConnections;
  }
}

// Export singleton instance
export const knowledgeConnections = new KnowledgeConnectionManager();